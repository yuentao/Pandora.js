/*兼容处理*/
//requestAnimationFrame
(function () {
  let lastTime = 0,
    vendors = ['webkit', 'moz'];
  for (let x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];
  }

  if (!window.requestAnimationFrame)
    window.requestAnimationFrame = callback => {
      let currTime = new Date().getTime();
      let timeToCall = Math.max(0, 16 - (currTime - lastTime));
      let id = window.setTimeout(() => {
          callback(currTime + timeToCall);
        },
        timeToCall);
      lastTime = currTime + timeToCall;
      return id;
    };

  if (!window.cancelAnimationFrame)
    window.cancelAnimationFrame = id => {
      clearTimeout(id);
    };
}());
const PandoraAPI = class {
  constructor(element = "html") {
    this.element = element;
    this.getEle = ele => {
      if (document.querySelectorAll(ele).length > 1) {
        return document.querySelectorAll(ele);
      } else {
        return document.querySelector(ele);
      }
    };
    this.init = () => {
      const ele = this.getEle(element);
      ele.eventList = [];
      return ele;
    };
    this.get = this.init();
    //生产PandoraId
    this.pid = `PandoraAPI_${new Date().getTime()}`;
    //默认参数赋值
    this.extend = (config, options) => {
      if (!options) {
        options = config;
      } else {
        Object.keys(config).forEach(e => {
          if (typeof (options[e]) === "undefined") options[e] = config[e];
        });
      }
      return options;
    };
    //选择指定下标元素
    this.eq = index => {
      this.get = this.getEle(element)[index];
      return this;
    };
    //选择子级元素
    this.child = name => {
      const ele = this.get;
      if (ele.querySelectorAll(name).length > 1) {
        this.get = ele.querySelectorAll(name);
      } else {
        this.get = ele.querySelector(name);
      }
      return this;
    };
    //选择父级元素
    this.parent = () => {
      const ele = this.get;
      this.get = ele.parentElement;
      return this;
    }
    //遍历元素集
    this.each = fn => {
      const ele = this.get;
      for (let a = 0; a < ele.length; a++) fn(ele, a);
    };
    //获取或修改样式
    this.css = name => {
      const ele = this.get;
      let style = [];
      style = name;
      if (style) {
        if (typeof (style) === "string") {
          return window.getComputedStyle(ele).getPropertyValue(style);
        } else {
          Object.keys(style).forEach(e => {
            ele.style[e] = style[e];
          });
        }
      }
      return this;
    };
    //获取或插入文本
    this.text = str => {
      const ele = this.get;
      if (str) {
        const text = document.createTextNode(str);
        ele.innerHTML = "";
        ele.appendChild(text);
      } else {
        return ele.firstChild.nodeValue;
      }
      return this;
    };
    //获取或插入HTML
    this.html = content => {
      const ele = this.get;
      if (content) {
        for (let el of ele.children) {
          ele.removeChild(el);
        }
        ele.innerHTML = content;
      } else {
        return ele.innerHTML;
      }
      return this;
    };
    //获取或插入值
    this.val = value => {
      const ele = this.get;
      value && (ele.value = value);
      return ele.value;
    };
    //插入元素
    this.prepend = target => {
      const ele = this.get;
      const Thetarget = `${target}${ele.innerHTML}`;
      ele.innerHTML = Thetarget;
      return this;
    };
    this.append = target => {
      const ele = this.get;
      const Thetarget = `${ele.innerHTML}${target}`;
      ele.innerHTML = Thetarget;
      return this;
    };
    //清空容器
    this.empty = () => {
      const ele = this.get;
      const empty = () => {
        for (let con of ele.children) {
          ele.removeChild(con);
          empty();
        }
      };
      empty();
      return this;
    };
    //移除元素
    this.remove = () => {
      const ele = this.get;
      const remove = () => {
        ele.parentElement.removeChild(ele);
        remove();
      }
      remove();
      return this;
    };
    //添加class
    this.addClass = name => {
      const ele = this.get;
      const beforeClass = ele.classList.value;
      if (beforeClass) {
        ele.className = `${beforeClass} ${name.trim()}`;
      } else {
        ele.className = name.trim();
      }
      return this;
    };
    //移除class
    this.removeClass = name => {
      const ele = this.get;
      let beforeClass = ele.classList.value.split(" "),
        afterClass;
      beforeClass.map((cur, idx) => {
        if (cur === name) beforeClass.splice(idx, 1);
      });
      afterClass = beforeClass.join(" ");
      ele.className = afterClass;
      return this;
    };
    //是否拥有class名
    this.hasClass = name => {
      const ele = this.get;
      const classlist = ele.classList.value.split(" ");
      if (classlist.indexOf(name) > 0) {
        return !0;
      } else {
        return !1;
      }
    };
    //添加属性
    this.attr = (name, val = null) => {
      const ele = this.get;
      if (val) {
        ele.setAttribute(name, val);
        return this;
      } else {
        return ele.getAttribute(name);
      }
    };
    //移除属性
    this.removeAttr = name => {
      const ele = this.get;
      ele.removeAttribute(name);
      return this;
    };
    //绑定事件
    this.bind = (eventName, fn, bool = !1) => {
      const ele = this.get;
      console.log(ele);
      ele.addEventListener(eventName, fn, bool);
      ele.eventList.push({
        name: eventName,
        callback: fn
      });
      return this;
    };
    //解绑事件
    this.unbind = eventName => {
      const ele = this.get;
      ele.eventList.map((e, i) => {
        if (e.name === eventName) {
          ele.removeEventListener(eventName, e.callback);
          ele.eventList.splice(i, 1);
        }
      });
      return this;
    };
    //点击事件
    this.click = fn => {
      const ele = this.get;
      for (let a = 0; a < ele.length; a++) {
        if (window.ontouchstart === undefined) {
          ele[a].onclick = fn;
          return this;
        } else {
          let x1, y1, x2, y2;
          ele[a].ontouchstart = event => {
            const touches = event.changedTouches[0];
            x1 = touches.clientX;
            y1 = touches.clientY;
          };
          ele[a].ontouchend = event => {
            const touches = event.changedTouches[0];
            x2 = touches.clientX;
            y2 = touches.clientY;
            if (x1 === x2 && y1 === y2) {
              setTimeout(() => {
                fn(event);
              }, 0);
            }
          };
        }
      }
      return this;
    };
    //长按事件
    this.taping = fn => {
      const ele = this.get;
      try {
        window.ontouchstart;
      } catch (err) {
        ele.onclick = fn;
        return this;
      }
      let infiniteFrame;
      const infiniteFn = () => {
        fn();
        infiniteFrame = requestAnimationFrame(infiniteFn);
      }
      ele.ontouchstart = () => {
        event.preventDefault();
        cancelAnimationFrame(infiniteFn);
        infiniteFn();
      }
      ele.ontouchend = () => {
        cancelAnimationFrame(infiniteFrame);
        return this;
      }
    };
    //失焦事件
    this.blur = fn => {
      const ele = this.get;
      ele.onblur = fn;
      return this;
    };
    //聚焦事件
    this.focus = fn => {
      const ele = this.get;
      ele.onfocus = fn;
      return this;
    };
    //改变事件
    this.change = fn => {
      const ele = this.get;
      ele.onchange = fn;
      return this;
    };
    //输入事件
    this.input = fn => {
      const ele = this.get;
      ele.oninput = fn;
      return this;
    };
    //悬浮事件
    this.hover = (In, Out) => {
      const ele = this.get;
      ele.onmouseover = In;
      if (Out) ele.onmouseout = Out;
      return this;
    };
    //滚动事件
    this.scroll = fn => {
      const ele = this.get;
      ele.onscroll = fn;
      return this;
    };
    //过渡结束事件
    this.ontransition = fn => {
      const ele = this.get;
      try {
        window.ontransitionend;
      } catch (err) {
        return !1;
      }
      ele.addEventListener("transitionend", fn);
      return this;
    };
    //动画结束事件
    this.animated = fn => {
      const ele = this.get;
      let isAnimated = !1;
      ele.addEventListener("animationend", () => {
        if (!isAnimated) {
          isAnimated = !0;
          fn();
        }
      });
      return this;
    };
    //显示
    this.show = () => {
      if (this.attr("beforeHide")) {
        this.css({
          "display": this.attr("beforeHide")
        });
      } else {
        this.css({
          "display": "block"
        });
      }
      return this;
    };
    //隐藏
    this.hide = () => {
      if (!this.attr("beforehide")) this.attr("beforeHide", this.css("display"));
      this.css({
        "display": "none"
      });
      return this;
    };
    //ajax
    this.ajax = options => {
      let config = {
        //接口地址(类型：字符串)
        url: null,
        //请求类型(类型：字符串；可选参数：post、get)
        type: "get",
        //是否同步请求(类型：布尔)
        async: !1,
        //发送数据类型(类型：字符串；可选参数：json、form)
        dataType: "json",
        //发送数据(类型：json或form；格式必须和发送数据类型保持一致)
        data: null,
        //成功回调方法(类型：方法；返回类型：对象)
        success: null,
        //失败回调方法(类型：方法)
        error: null
      };
      config = this.extend(config, options);
      const http = new XMLHttpRequest();
      let params;
      if (config.dataType == "json") {
        if (config.data) params = Object.keys(config.data).map(key => {
          return `${encodeURIComponent(key)}=${encodeURIComponent(config.data[key])}`;
        }).join("&");
      } else {
        params = config.data;
      }

      http.onload = () => {
        if (http.status === 200 || http.statusText === "OK" || http.readyState === 4) {
          const res = http.response;
          try {
            JSON.parse(res);
          } catch (err) {
            config.success && config.success(res);
            return !1;
          }
          config.success && config.success(JSON.parse(res));
        }
      }
      http.onerror = config.error ? config.error() : null;
      http.open(config.type.toUpperCase(), config.url, config.async);
      if (config.dataType == "json") http.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
      http.send(params);
    };
  }
}
const PandoraJs = (SuperClass = null) => {
  SuperClass = SuperClass || class Empty {};
  return class extends SuperClass {
    constructor(element) {
      super(element);
    }
    //Mustache渲染
    Mustache(options) {
      let config = {
        //全局变量名(类型：字符串)
        globalName: "Pd_MUST",
        //渲染数据(类型：对象；动态修改变量方法 window[全局变量名].渲染数据)
        data: null,
        //元素事件(类型：方法)
        Bind: null
      };
      config = this.extend(config, options);
      let Html = this.html(),
        bHtml = Html,
        pattern = new RegExp("{.*?}", "g"),
        patterns = new RegExp("{.*?}", ""),
        matchValue;
      window[config.globalName] = {};

      const result = () => {
        let r = [];
        Html.match(pattern).forEach((e, index) => {
          r[index] = e.split("{")[1].split("}")[0];
        });
        return r;
      };

      //渲染html
      const renderHtml = () => {
        for (let value of matchValue) {
          for (let keyName in config.data) {
            if (value === keyName) Html = bHtml.replace(patterns, config.data[value]);
          }
        }
        this.html(Html);
        !!config.Bind && eval(config.Bind);
      };

      //遍历变量是否被动态修改
      const unique = array => {
        let r = [];
        for (let i = 0, l = array.length; i < l; i++) {
          for (let j = i + 1; j < l; j++)
            if (array[i] == array[j]) j == ++i;
          r.push(array[i]);
        }
        return r;
      };

      matchValue = result();
      renderHtml();
      const realVal = unique(matchValue);
      realVal.forEach(e => {
        Object.defineProperty(window[config.globalName], e, {
          set: value => {
            config.data[e] = value;
            renderHtml();
          }
        });
      });
      return this;
    }
    //静态路由
    Router(options) {
      let config = {
        //重定向路径(类型：字符串)
        direct: "index",
        //路由类型(类型：字符串)
        type: ".html",
        //参数保存方式(类型：字符串；可选参数：session，local)
        storage: "session"
      };
      config = this.extend(config, options);
      const routerView = this.getEle(this.element),
        loaded = res => {
          for (let routerViews of routerView.children) routerView.removeChild(routerViews);
          this.html(res);
          eachEle();
          let script = routerView.getElementsByTagName("script");
          for (let scriptText of script)(new Function(scriptText.text))();
          script = null;
        };

      let routerLink, param, paramKey = [],
        paramValue = [],
        dataObj = {},
        getParam = url => {
          if (url.indexOf("?") > 0) {
            param = url.split("?")[1].split("&");
            param.forEach((cur, index) => {
              paramKey[index] = cur.split("=")[0];
              paramValue[index] = cur.split("=")[1];
            });

            paramKey.forEach((key, index) => {
              dataObj[key] = paramValue[index];
            });
            switch (config.storage) {
              case "session":
                sessionStorage.setItem(`Pd-data[${url.split("?")[0].toString()}]`, JSON.stringify(dataObj));
                break;
              case "local":
                localStorage.setItem(`Pd-data[${url.split("?")[0].toString()}]`, JSON.stringify(dataObj));
                break;
            }
            return url.split("?")[0];
          }
          return url;
        };

      let eachEle = () => {
        for (let thats of this.getEle("*")) {
          let routerLink = thats.getAttribute("Pd-router");
          if (routerLink) {
            thats.onclick = () => {
              routerLink = getParam(routerLink);
              this.ajax({
                url: `${routerLink}${config.type}`,
                success: loaded
              });
            };
          }
        }
        routerLink = null, param = null, paramKey.length = 0, paramValue.length = 0, dataObj = {};
      };
      eachEle();

      let prepend = () => {
        if (config.direct) {
          routerLink = getParam(config.direct);
          this.ajax({
            url: `${routerLink}${config.type}`,
            success: loaded
          });
          routerLink = null, param = null, paramKey.length = 0, paramValue.length = 0, dataObj = {};
        }
      };
      prepend();
      return this;
    }
    //轮播切换
    Switcher(options) {
      let config = {
        //上一个按钮(类型：字符串)
        Btn_Prev: null,
        //下一个按钮(类型：字符串)
        Btn_Next: null,
        //过渡速度/秒(类型：数字)
        Speed: 1,
        //动画曲线(类型：字符串；参考css3动画曲线)
        Curve: "ease",
        //切换效果(类型：字符串；可选参数：slider、fade)
        Effect: "slider",
        //方向(类型：字符串；可选参数：horizontal、vertical)
        Direction: "horizontal",
        //滑动比例(类型：数字)
        Distance: 3,
        //自动切换间隔/秒(类型：数字；为0时不自动切换)
        AutoSpeed: 0,
        //分页器(类型：布尔)
        Pagination: !1,
        //悬浮停止(类型：布尔)
        Hover: !1,
        //滚轮滚动(类型：布尔)
        Scroll: !1,
        //初始坐标(类型：数字)
        InitPage: 0,
        //循环(类型：布尔)
        Loop: !1
      };
      config = this.extend(config, options);
      const $ = this.getEle,
        childEle = this.get,
        parentEle = new PandoraAPI(this.element).eq(0).parent();
      let childW = childEle[0].offsetWidth,
        childH = childEle[0].offsetHeight,
        cur = config.InitPage,
        AutoTimeout, isScrolling = !1;
      const total = childEle.length,
        transitionend = () => {
          if (isScrolling) {
            isScrolling = !1;
            parentEle.unbind("transitionend");
          }
        };

      //禁用切换
      const Disable = () => {
        new PandoraAPI(config.Btn_Prev).unbind("click");
        new PandoraAPI(config.Btn_Next).unbind("click");
        if (config.Loop) {
          new PandoraAPI(config.Btn_Prev).bind("click", Prev);
          new PandoraAPI(config.Btn_Next).bind("click", Next);
        } else {
          if (cur === 0) {
            new PandoraAPI(config.Btn_Prev).removeClass("disable");
            new PandoraAPI(config.Btn_Prev).addClass("disable");
            new PandoraAPI(config.Btn_Next).bind("click", Next);
          } else if (cur === total - 1) {
            new PandoraAPI(config.Btn_Next).removeClass("disable");
            new PandoraAPI(config.Btn_Next).addClass("disable");
            new PandoraAPI(config.Btn_Prev).bind("click", Prev);
          } else {
            new PandoraAPI(config.Btn_Prev).removeClass("disable");
            new PandoraAPI(config.Btn_Next).removeClass("disable");
            new PandoraAPI(config.Btn_Prev).bind("click", Prev);
            new PandoraAPI(config.Btn_Next).bind("click", Next);
          }
        }
      };

      //切换
      const Swiper = () => {
        Pagination(cur);
        switch (config.Effect) {
          case "fade":
            for (let cur of childEle) cur.style.opacity = `0`;
            childEle[cur].style.opacity = `1`;
            break;
          default:
            switch (config.Direction) {
              case "horizontal":
                parentEle.css({
                  "transform": `translate3d(${-1 * (childW * cur)}px,0,0)`
                })
                break;
              case "vertical":
                parentEle.css({
                  "transform": `translate3d(0,${-1 * (childH * cur)}px,0)`
                })
                break;
            }
            break;
        }
        if (config.Loop) {
          parentEle.bind("transitionend", transitionend);
        } else {
          if (cur === 0 || cur === total - 1) {
            transitionend();
          } else {
            parentEle.bind("transitionend", transitionend);
          }
        }
        if ($(config.Btn_Prev) !== null && $(config.Btn_Next) !== null) Disable();
      };

      //分页器
      const Pagination = current => {
        for (let e of childEle) e.className = e.className.replace("active", "").trim();
        if (childEle[cur].className) {
          childEle[cur].className += " active";
        } else {
          childEle[cur].className += "active";
        }
        if (config.Pagination) {
          parentEle.get.parentElement.querySelector(".Pd-pagination") && parentEle.get.parentElement.removeChild(parentEle.parentElement.querySelector(".Pd-pagination"));
          let pager = document.createElement("div");
          pager.className = "Pd-pagination";

          for (let a = 0; a < total; a++) {
            let pageChild = document.createElement("a"),
              textNode = childEle[a].getAttribute("data-title") ? document.createTextNode(childEle[a].getAttribute("data-title")) : document.createTextNode(a);
            pageChild.setAttribute("href", "javascript:void 0");
            if (a === current) pageChild.className = "active";
            pageChild.appendChild(textNode);
            pager.appendChild(pageChild);
          }
          parentEle.get.parentElement.insertBefore(pager, parentEle.get.nextElementSibling);
          for (let a = 0; a < parentEle.get.parentElement.querySelector(".Pd-pagination").querySelectorAll("a").length; a++) {
            let e = parentEle.get.parentElement.querySelector(".Pd-pagination").querySelectorAll("a")[a];
            let idx = a;
            e.onclick = () => {
              cur = idx;
              Swiper();
            }
          }
        }
      };

      //上一个
      const Prev = () => {
        if (cur < total && cur > 0) {
          cur--;
        } else if (cur === 0 && config.Loop) {
          cur = total - 1;
        } else {
          isScrolling = !1;
        }
        Swiper();
      };

      //下一个
      const Next = () => {
        if (cur < total - 1) {
          cur++;
        } else if (cur === total - 1 && config.Loop) {
          cur = 0;
        } else {
          cur = total - 1;
        }
        Swiper();
      };

      let startX, startY, endX, endY, curX, curY;
      //方法：滑动开始
      const touchStart = event => {
        clearTimeout(AutoTimeout);
        cancelAnimationFrame(AutoPlayFrame);
        switch (config.Direction) {
          case "horizontal":
            startX = event.changedTouches[0].pageX - parentEle.get.parentElement.getBoundingClientRect().left;
            break;
          case "vertical":
            startY = event.changedTouches[0].pageY - parentEle.get.parentElement.getBoundingClientRect().top;
            break;
        }
        parentEle.css({
          "transition": null
        });
      };

      //方法：滑动中
      const touchMove = event => {
        curX = event.changedTouches[0].pageX - parentEle.get.parentElement.getBoundingClientRect().left;
        curY = event.changedTouches[0].pageY - parentEle.get.parentElement.getBoundingClientRect().top;
        switch (config.Effect) {
          case "fade":
            for (let cur of childEle) cur.style.transition = `opacity ${config.Speed}s linear`;
            break;
          default:
            switch (config.Direction) {
              case "horizontal":
                if (startX > curX) {
                  parentEle.css({
                    "transform": `translate3d(${-1 * (startX - curX + (childW * cur))}px,0,0)`
                  });
                } else {
                  parentEle.css({
                    "transform": `translate3d(${-1 * (childW * cur) + Math.abs(curX - startX)}px,0,0)`
                  });
                }
                break;
              case "vertical":
                if (startY > curY) {
                  parentEle.css({
                    "transform": `translate3d(0,${-1 * (startY - curY + (childH * cur))}px,0)`
                  });
                } else {
                  parentEle.css({
                    "transform": `translate3d(0,${-1 * (childH * cur) + Math.abs(curY - startY)}px,0)`
                  });
                }
                break;
            }
            break;
        }
      };

      //方法：滑动结束
      const touchEnd = event => {
        clearTimeout(AutoTimeout);
        AutoPlay();
        parentEle.css({
          "transition": `transform ${config.Speed}s ${config.Curve}`
        });
        switch (config.Direction) {
          case "horizontal":
            endX = event.changedTouches[0].pageX - parentEle.get.parentElement.getBoundingClientRect().left;
            switch (config.Effect) {
              case "fade":
                if (startX - endX > childW / config.Distance && cur === total - 1) {
                  cur = 0;
                } else if (startX - endX > childW / config.Distance && cur < total - 1) {
                  Next();
                } else if (endX - startX > childW / config.Distance) {
                  Prev();
                }
                for (let cur of childEle) {
                  cur.style.transition = `opacity ${config.Speed}s ${config.Curve}`;
                  cur.style.opacity = 0;
                }
                childEle[cur].style.opacity = 1;
                Swiper();
                break;
              default:
                if (startX - endX > childW / config.Distance && cur < total - 1) Next();
                if (endX - startX > childW / config.Distance) Prev();
                parentEle.css({
                  "transform": `translate3d(${-1 * (childW * cur)}px,0,0)`
                });
                break;
            }
            break;
          case "vertical":
            endY = event.changedTouches[0].pageY - parentEle.get.parentElement.getBoundingClientRect().top;
            switch (config.Effect) {
              case "fade":
                if (startY - endY > childH / config.Distance && cur === total - 1) {
                  cur = 0;
                } else if (startY - endY > childH / config.Distance && cur < total - 1) {
                  Next();
                } else if (endY - startY > childH / config.Distance) {
                  Prev();
                }
                for (let cur of childEle) {
                  cur.style.transition = `opacity ${config.Speed}s ${config.Curve}`;
                  cur.style.opacity = 0;
                }
                childEle[cur].style.opacity = 1;
                Swiper();
                break;
              default:
                if (startY - endY > childH / config.Distance && cur < total - 1) Next();
                if (endY - startY > childH / config.Distance) Prev();
                parentEle.css({
                  "transform": `translate3d(0,${-1 * (childH * cur)}px,0)`
                });
                break;
            }
            break;
        }
      };

      //方法：滚动中
      const scrollMove = event => {
        event.preventDefault();
        if (event.deltaY > 20 && !isScrolling) {
          isScrolling = !0;
          Next();
        }
        if (event.deltaY < -20 && !isScrolling) {
          isScrolling = !0;
          Prev();
        }
      }

      //自动播放
      let AutoPlayFrame;
      const AutoPlay = () => {
        if (config.AutoSpeed > 0) {
          AutoTimeout = setTimeout(() => {
            Next();
            clearTimeout(AutoTimeout);
            AutoPlayFrame = requestAnimationFrame(AutoPlay);
          }, config.AutoSpeed * 1000);
        }
      };

      //初始化
      const Init = () => {
        childW = new PandoraAPI(this.element).get.offsetWidth;
        childH = new PandoraAPI(this.element).get.offsetHeight;
        cur = config.InitPage;

        new Promise(next => {
          switch (config.Effect) {
            case "fade":
              for (let cur of childEle) {
                cur.style.transition = `opacity ${config.Speed}s ${config.Curve}`;
                cur.style.position = "absolute";
              }
              break;
            default:
              switch (config.Direction) {
                case "horizontal":
                  parentEle.css({
                    "flex-direction": "row",
                    "width": `${childW * total}px`
                  });
                  break;
                case "vertical":
                  parentEle.css({
                    "flex-direction": "column",
                    "width": `${childW * total}px`
                  });
                  break;
              }
              parentEle.css({
                "display": "flex",
                "transition": `transform ${config.Speed}s ${config.Curve}`
              });
              break;
          }
          next();
        }).then(() => {
          //移除事件
          if ($(config.Btn_Prev) !== null && $(config.Btn_Next) !== null) {
            new PandoraAPI(config.Btn_Prev).unbind("click", Prev);
            new PandoraAPI(config.Btn_Next).unbind("click", Next);
          }
          Swiper(config.InitPage);
          AutoPlay();
          parentEle.get.parentElement.removeEventListener("touchmove", touchMove);
          parentEle.get.parentElement.removeEventListener("touchstart", touchStart);
          parentEle.get.parentElement.removeEventListener("touchend", touchEnd);
          config.Scroll && parentEle.get.parentElement.removeEventListener("mousewheel", scrollMove);
        }).then(() => {
          //添加事件
          parentEle.get.parentElement.addEventListener("touchmove", touchMove);
          parentEle.get.parentElement.addEventListener("touchstart", touchStart);
          parentEle.get.parentElement.addEventListener("touchend", touchEnd);
          config.Scroll && parentEle.get.parentElement.addEventListener("mousewheel", scrollMove);
          if (config.Hover) {
            parentEle.bind("mouseover", () => {
              clearTimeout(AutoTimeout);
              cancelAnimationFrame(AutoPlayFrame);
            });
            parentEle.bind("mouseout", AutoPlay);

            if ($(config.Btn_Prev) !== null && $(config.Btn_Next) !== null) {
              new PandoraAPI(config.Btn_Prev).bind("mouseover", () => {
                clearTimeout(AutoTimeout);
                cancelAnimationFrame(AutoPlayFrame);
              });
              new PandoraAPI(config.Btn_Next).bind("mouseover", () => {
                clearTimeout(AutoTimeout);
                cancelAnimationFrame(AutoPlayFrame);
              });
              new PandoraAPI(config.Btn_Prev).bind("mouseout", AutoPlay);
              new PandoraAPI(config.Btn_Next).bind("mouseout", AutoPlay);
            }
          }
        });
      };

      //图片加载器
      Init();
      let req;
      window.addEventListener("resize", () => {
        cancelAnimationFrame(req);
        req = requestAnimationFrame(Init);
      });
      return this;
    }
    //字体自适应
    AutoSize(options) {
      let config = {
        //固定尺寸(类型：字符串)
        PageSize: "device-width",
        //初始缩放(类型：数字)
        InitScale: 1,
        //最小缩放(类型：数字)
        MinScale: 1,
        //最大缩放(类型：数字)
        MaxScale: 1,
        //DPI缩放(类型：数字)
        Ratio: 1
      };
      config = this.extend(config, options);
      const $ = this.getEle,
        meta = document.createElement("meta");
      meta.setAttribute("name", "viewport");
      if (typeof (config.PageSize) !== "number") {
        meta.setAttribute("content", `width=${config.PageSize},initial-scale=${config.InitScale},minimum-scale=${config.MinScale},maximum-scale=${config.MaxScale},user-scalable=no,viewport-fit=cover`);
      } else {
        meta.setAttribute("content", `width=${config.PageSize},user-scalable=no,viewport-fit=cover`);
      }
      $("head").appendChild(meta);

      const SetSize = () => {
        let platform = navigator.userAgent.toLowerCase(),
          deviceList = ["iphone", "android"],
          isMobile = !1;

        deviceList.forEach(c => {
          if (isMobile) return !1;
          if (platform.indexOf(c) > 0) {
            isMobile = !0;
            let calcFontSize = (window.screen.width / 3.75) * config.Ratio;
            $("html").style.fontSize = `${calcFontSize}px`;
          } else {
            $("html").style.fontSize = "inherit";
          }
        });
      };
      SetSize();
      window.onresize = SetSize;
      return this;
    }
    //自定义弹框
    Dialog(options) {
      let config = {
        //遮罩颜色(类型：字符串)
        maskColor: "rgba(0,0,0,.85)",
        //点击遮罩退出(类型：布尔)
        maskOut: !0,
        //过渡速度/毫秒(类型：数字)
        Speed: 180,
        //过渡曲线(类型：字符串；参考CSS3可用曲线)
        Curve: "ease-out",
        //进出方式(类型：字符串；none:无、zoom:缩放、top:从屏幕上方出现、bottom:从屏幕下方出现)
        Direction: "zoom",
        //进入事件(类型：方法)
        In: null,
        //退出事件(类型：方法)
        Out: null,
        //确认事件
        Confrim: {
          //确定按钮(类型：字符串)
          btn: null,
          //回调(类型：方法；返回类型：对象)
          callback: null
        },
        //取消事件
        Cancel: {
          //取消按钮(类型：字符串)
          btn: null,
          //回调(类型：方法；返回类型：对象)
          callback: null
        }
      };
      const that = this;
      const $ = that.getEle;
      config = that.extend(config, options);
      let mask = document.createElement("div"),
        parent = $(that.element).parentElement;
      mask.className = "Pd-Mask";
      window["Pd_Dialog"] = {};
      window["Pd_Dialog"].config = config;
      parent.insertBefore(mask, $(that.element).nextElementSibling);

      new PandoraAPI(".Pd-Mask").css({
        "width": "100vw",
        "height": "100vh",
        "background": config.maskColor,
        "position": "fixed",
        "top": 0,
        "left": 0,
        "z-index": 998
      });

      if (config.Direction !== "none") that.css({
        "transition": `all ${config.Speed}ms ${config.Curve}`
      });

      //退出动画
      const outEffect = () => {
        Effect("out");
        if (config.Direction === "none") {
          closeDialog();
        } else {
          $(that.element).addEventListener("transitionend", closeDialog);
        }
      };

      //移除遮罩
      const closeDialog = () => {
        parent.removeChild(mask);
        that.css({
          "display": "none"
        });
        $(that.element).removeEventListener("transitionend", closeDialog);
        config.Confrim.btn && $(config.Confrim.btn).removeEventListener("click", confrim_callback);
        config.Cancel.btn && $(config.Cancel.btn).removeEventListener("click", cancel_callback);
        $(that.element).removeEventListener("transitionend", closeDialog);
        delete window["Pd_Dialog"];
      };

      //回调事件
      const confrim_callback = () => {
        if (typeof window["Pd_Dialog"].config.Confrim.callback === "function") window["Pd_Dialog"].config.Confrim.callback(window["Pd_Dialog"])
      };
      const cancel_callback = () => {
        if (typeof window["Pd_Dialog"].config.Cancel.callback === "function") window["Pd_Dialog"].config.Cancel.callback(window["Pd_Dialog"]);
      };

      //进入和退出效果
      const Effect = where => {
        switch (where) {
          case "in":
            switch (config.Direction) {
              case "none":
                that.css({
                  "display": "block"
                });
                break;
              case "zoom":
                that.css({
                  "display": "block",
                  "transform": "translate3d(0,0,0) scale(0)"
                });
                break;
              case "top":
                that.css({
                  "display": "block",
                  "transform": "translate3d(0,-100%,0)"
                });
                break;
              case "bottom":
                that.css({
                  "display": "block",
                  "transform": "translate3d(0,100%,0)"
                });
                break;
            }
            if (typeof window["Pd_Dialog"].config.In === "function") config.In(window["Pd_Dialog"]);
            break;
          case "out":
            switch (config.Direction) {
              case "none":
                that.css({
                  "display": "none"
                });
                break;
              case "zoom":
                that.css({
                  "transform": "translate3d(0,0,0) scale(0)"
                });
                break;
              case "top":
                that.css({
                  "transform": "translate3d(0,-100%,0)"
                });
                break;
              case "bottom":
                that.css({
                  "transform": "translate3d(0,100%,0)"
                });
                break;
            }
            if (typeof window["Pd_Dialog"].config.Out === "function") config.Out(window["Pd_Dialog"]);
            break;
        }
      };

      new Promise(next => {
        Effect("in");
        setTimeout(next, 50);
      }).then(() => {
        let top = parseInt(that.css("height")) / 2,
          left = parseInt(that.css("width")) / 2;
        switch (config.Direction) {
          case "none":
            that.css({
              "position": "fixed",
              "top": `calc(50% - ${top}px)`,
              "left": `calc(50% - ${left}px)`,
              "z-index": 999,
              "transform": "translate3d(0,0,0) scale(1)"
            });
            break;
          case "zoom":
            that.css({
              "position": "fixed",
              "top": `calc(50% - ${top}px)`,
              "left": `calc(50% - ${left}px)`,
              "z-index": 999,
              "transform": "translate3d(0,0,0) scale(1)"
            });
            break;
          case "top":
            that.css({
              "position": "fixed",
              "top": 0,
              "left": `calc(50% - ${left}px)`,
              "z-index": 999,
              "transform": "translate3d(0,0,0) scale(1)"
            });
            break;
          case "bottom":
            that.css({
              "position": "fixed",
              "bottom": 0,
              "left": `calc(50% - ${left}px)`,
              "z-index": 999,
              "transform": "translate3d(0,0,0) scale(1)"
            });
            break;
        }
      }).then(() => {
        //遮罩被点击
        if (config.maskOut) mask.onclick = outEffect;
        //确认按钮被点击      
        config.Confrim.btn && $(config.Confrim.btn).addEventListener("click", confrim_callback);
        //取消按钮被点击      
        config.Cancel.btn && $(config.Cancel.btn).addEventListener("click", cancel_callback);
      }).then(() => {
        window["Pd_Dialog"].close = outEffect;
        this.hideDialog = outEffect;
      });

      return this;
    }
    //图片预加载
    ImgLoader(options) {
      let config = {
        //加载中(类型：方法；返回类型：数字)
        loading: null,
        //加载完成(类型：方法)
        callback: null,
        //加载错误(类型：方法)
        error: () => {
          console.error("资源加载错误");
          alert("资源加载错误");
        }
      };
      config = this.extend(config, options);
      const that = this,
        $ = that.getEle("*"),
        pattern = new RegExp('".*?"', "g"),
        pattern2 = new RegExp(/'.*?'/, "g"),
        pattern3 = new RegExp(/\(.*?\)/, "g");
      let ImgArr = [],
        total = 0,
        cur = 0,
        isERROR = !1,
        step = 0,
        floatNum = 0;

      for (let e of $) {
        if (e.nodeName.toLowerCase() == "img") {
          e.src && ImgArr.push(e.src);
        }
        if (window.getComputedStyle(e).getPropertyValue("background-image").indexOf("url") >= 0) {
          if (window.getComputedStyle(e).getPropertyValue("background-image") !== "none") {
            if (window.getComputedStyle(e).getPropertyValue("background-image").match(pattern)) ImgArr.push(window.getComputedStyle(e).getPropertyValue("background-image").match(pattern)[0].toString().replace(/"/g, ""));
            if (window.getComputedStyle(e).getPropertyValue("background-image").match(pattern2)) ImgArr.push(window.getComputedStyle(e).getPropertyValue("background-image").match(pattern2)[0].toString().replace(/'/g, ""));
            if (window.getComputedStyle(e).getPropertyValue("background-image").match(pattern3)) {
              let src = window.getComputedStyle(e).getPropertyValue("background-image").match(pattern3)[0].toString().replace(/\(/, "");
              src = src.replace(/\)/, "");
              if (src.match(pattern)) src = src.match(pattern)[0].toString().replace(/"/g, "");
              if (src.match(pattern2)) src = src.match(pattern2)[0].toString().replace(/'/g, "");

              ImgArr.push(src);
            }
          }
        }
      }

      let uniqueArr = [];
      ImgArr.map((cur, idx) => {
        if (ImgArr.indexOf(cur) == idx) uniqueArr.push(cur);
      });
      ImgArr = uniqueArr;
      total = ImgArr.length;

      ImgArr.map(e => {
        let img = new Image();
        img.src = e;

        img.onerror = () => {
          if (!isERROR) {
            isERROR = !0;
            config.error();
            img.onerror = null;
          }
        }
        if (img.complete) {
          cur++;
        } else {
          img.onload = () => {
            cur++;
            img.onload = null;
          }
        }
      });

      //加载中
      let loadingFrame;
      const loading = () => {
        isERROR && cancelAnimationFrame(loadingFrame);
        step = (cur / total) * 100;
        if (step < 100 && !isERROR) {
          if (step === 100) {
            cancelAnimationFrame(loadingFrame);
          } else {
            loadingFrame = requestAnimationFrame(loading);
          }
        }
      };
      loading();
      let loadstepFrame;
      const loadstep = () => {
        isERROR && cancelAnimationFrame(loadstepFrame);
        if (floatNum < 100 && !isERROR) {
          if (floatNum < step) floatNum++;
          that.getEle(that.element).setAttribute("Pd-load", floatNum);
          config.loading && config.loading(floatNum);
          if (floatNum === 100) {
            cancelAnimationFrame(loadstepFrame);
            config.callback && config.callback();
            loadstepFrame = null;
          } else {
            loadstepFrame = requestAnimationFrame(loadstep);
          }
        }
      }
      loadstep();
      return this;
    }
    //图片上传
    ImgUpload(options) {
      let config = {
        //接口地址(类型：字符串)
        apiUrl: "http://node.pandorajs.com/",
        //接口名称(类型：字符串)
        apiName: "Pd_uploadImage",
        //格式限制(类型：字符串)
        Format: "*",
        //选择类型(可选参数：defualt、camera)
        type: "default",
        //限制数量(类型：数字)
        Max: 1,
        //压缩比例(类型：数字)
        Quality: 100,
        //尺寸裁切
        Clip: {
          //宽度(类型：数字)
          width: null,
          //高度(类型：数字)
          height: null
        },
        //上传事件
        Events: {
          //超过限制(类型：方法)
          overMax: null,

          //开始上传(类型：方法)
          ready: null,
          //上传成功(类型：方法；返回类型：对象)
          success: null,
          //失败(类型：方法)
          fail: null
        },
        //唯一id(类型：字符串；如果为null，则启用临时上传，请谨慎使用)
        Uid: null
      };
      const that = this;
      that.pid;
      config = that.extend(config, options);
      const uploadcon = that.getEle(that.element),
        innerHtml = this.html();
      this.empty();
      uploadcon.insertAdjacentHTML("afterbegin", `<label for="Pd_imgupload_${that.pid}" style="width:100%;height:100%;display:block;"></label>`);
      let uploadBtn = document.createElement("input"),
        userId, total = config.Max,
        current = 0,
        steps = (current / total) * 100,
        mask;
      if (config.Uid !== null) {
        userId = config.Uid;
      } else {
        userId = `${document.domain}_${that.pid}`;
      }

      uploadBtn.type = "file";
      uploadBtn.accept = `image/${config.Format}`;
      uploadBtn.id = `Pd_imgupload_${that.pid}`;
      if (config.type === "camera") uploadBtn.setAttribute("capture", "camera")
      uploadBtn.style.display = "none";
      if (config.Max > 1) uploadBtn.multiple = !0;
      uploadcon.querySelector("label").innerHTML = innerHtml;
      uploadcon.querySelector("label").append(uploadBtn);

      if (!config.Events.ready) {
        if (document.getElementById("Pd-upload-Mask") === null) {
          mask = document.createElement("div");
          let svg = new Image();
          svg.src = "http://b.pandorajs.com/Pandora/src/loader.svg";
          mask.id = "Pd-upload-Mask";
          mask.appendChild(svg);
          document.body.appendChild(mask);
          new PandoraAPI("#Pd-upload-Mask").css({
            "width": "100%",
            "height": "100%",
            "position": "fixed",
            "z-index": "99",
            "top": 0,
            "let": 0,
            "background": "rgba(0,0,0,.95)",
            "display": "flex",
            "align-items": "center",
            "justify-content": "center"
          });
          new PandoraAPI("#Pd-upload-Mask").hide();
        }
      }

      //上传图片
      const uploadPreview = obj => {
        let formData = new FormData();
        formData.append("images", obj);
        formData.append("uid", userId);
        formData.append("width", config.Clip.width);
        formData.append("height", config.Clip.height);
        formData.append("quality", config.Quality);

        if (config.Events.ready) {
          config.Events.ready();
        } else {
          !config.Events.ready && new PandoraAPI("#Pd-upload-Mask").show();
        }

        this.ajax({
          url: `${config.apiUrl}${config.apiName}`,
          async: !0,
          type: "post",
          dataType: "form",
          data: formData,
          success: res => {
            current++;
            steps = (current / total) * 100;
            uploadBtn.setAttribute("data-progress", steps);
            if (steps === 100) {
              uploadBtn.disabled = !1;
              let data = {
                src: res.images
              };
              uploadBtn.value = "";
              !config.Events.ready && new PandoraAPI("#Pd-upload-Mask").hide();
              config.Events.success && config.Events.success(data);
            }
          },
          error: () => {
            uploadBtn.disabled = !1;
            uploadBtn.value = "";
            !config.Events.ready && new PandoraAPI("#Pd-upload-Mask").hide();
            config.Events.fail && config.Events.fail();
          }
        });
      }

      //获取选择文件
      const selectedFile = Files => {
        let files = Array.prototype.slice.call(Files);

        if (config.Max === 0 || files.length <= config.Max) {
          current = 0;
          uploadBtn.disabled = !0;
          total = files.length;

          if (total > 0) {
            files.forEach((file, idx) => {
              uploadPreview(Files[idx]);
            });
          }
        } else {
          config.Events.overMax && config.Events.overMax();
          console.info(`文件数量超过最大数量:${config.Max}`);
        }
      }

      //选择文件按钮事件
      uploadBtn.addEventListener("change", event => {
        event.preventDefault();
        selectedFile(event.target.files);
      });
      //拖动文件事件
      uploadcon.addEventListener("dragover", event => {
        event.preventDefault();
      });
      uploadcon.addEventListener("drop", event => {
        event.preventDefault();
        selectedFile(event.dataTransfer.files);
      });
      return this;
    }
    //图片移动缩放
    ImgTransit(options) {
      let config = {
        //显示控制图标(类型：布尔)
        icon: !0,
        //控制图标大小(类型：数字)
        iconSize: 40,
        //显示边框(类型：布尔)
        border: !0,
        //内边距(类型：数字)
        padding: 0,
        //缩放
        scale: {
          //是否启用(类型：布尔)
          enable: !0,
          //最小(类型：数字)
          min: 50,
          //最大(类型：数字)
          max: 200,
          //速率(类型：数字)
          rate: 1
        },
        //是否移动(类型：布尔)
        move: !0,
        //旋转
        rotate: {
          //是否启用(类型：布尔)
          enable: !0,
          //速率(类型：数字)
          rate: 1
        },
        //是否启用删除(类型：布尔)
        delete: !0,
        //边界限制(类型：布尔)
        bounds: !0,
        //边界可超出范围(类型：数字)
        outBounds: 0,
        //操作回调方法(类型：方法；返回类型：对象)
        callback: null
      };
      config = this.extend(config, options);
      let that = this,
        imgRealArr = that.getEle(that.element).querySelectorAll("img"),
        beforImgArr = Array.prototype.slice.call(imgRealArr),
        imgArr = [],
        imgIndex = [],
        btnAnimation = `transition:opacity .2s ease-in`,
        topIndex, canMove = !0;

      beforImgArr.forEach((cur, idx) => {
        if (JSON.parse(cur.getAttribute("Pd-move"))) {
          imgIndex.push(idx);
          imgArr.push(cur);
        }
      });
      topIndex = imgArr.length;

      //图标配置
      let icon = {
        resize: `<a class="Pd-ImgTransit-btn Pd-resize" style="width:${config.iconSize}px;height:${config.iconSize}px;background:#fff url('http://b.pandorajs.com/Pandora/src/resize.svg');background-position:center;background-repeat:no-repeat;background-size:65%;position:absolute;border-radius:50%;left:-${config.iconSize/2}px;bottom:-${config.iconSize/2}px;z-index:2;${btnAnimation}" href="javascript:void 0"></a>`,
        rotate: `<a class="Pd-ImgTransit-btn Pd-rotate" style="width:${config.iconSize}px;height:${config.iconSize}px;background:#fff url('http://b.pandorajs.com/Pandora/src/rotate.svg');background-position:center;background-repeat:no-repeat;background-size:65%;position:absolute;border-radius:50%;right:-${config.iconSize/2}px;top:-${config.iconSize/2}px;z-index:2;${btnAnimation}" href="javascript:void 0"></a>`,
        delete: `<a class="Pd-ImgTransit-btn Pd-delete" style="width:${config.iconSize}px;height:${config.iconSize}px;background:#fff url('http://b.pandorajs.com/Pandora/src/delete.svg');background-position:center;background-repeat:no-repeat;background-size:65%;position:absolute;border-radius:50%;left:-${config.iconSize/2}px;top:-${config.iconSize/2}px;z-index:2;${btnAnimation}" href="javascript:void 0"></a>`
      };

      //添加手势事件
      const addGesture = () => {
        let istouch = !1,
          start = [],
          gesturestart = new CustomEvent('gesturestart'),
          gesturechange = new CustomEvent('gesturechange'),
          gestureend = new CustomEvent('gestureend');

        const getDistance = (p1, p2) => {
          let x = p2.pageX - p1.pageX,
            y = p2.pageY - p1.pageY;
          return Math.sqrt((x * x) + (y * y));
        };
        const getAngle = (p1, p2) => {
          let x = p1.pageX - p2.pageX,
            y = p1.pageY - p2.pageY;
          return Math.atan2(y, x) * 180 / Math.PI;
        };

        document.addEventListener("touchstart", e => {
          if (e.touches.length >= 2) { //判断是否有两个点在屏幕上
            canMove = !1;
            istouch = !0;
            start = e.touches; //得到第一组两个点
            let now = e.touches,
              scale = getDistance(now[0], now[1]) / getDistance(start[0], start[1]); //得到缩放比例
            gesturestart.scale = Number(scale.toFixed(2));
            gesturestart.touches = start;
            e.target.dispatchEvent(gesturestart);
          }
        }, !1);

        document.addEventListener("touchmove", e => {
          e.preventDefault();
          if (e.touches.length >= 2 && istouch) {
            canMove = !1;
            let now = e.touches,
              scale = getDistance(now[0], now[1]) / getDistance(start[0], start[1]),
              rotation = getAngle(now[0], now[1]) - getAngle(start[0], start[1]); //得到旋转角度差
            gesturechange.scale = Number(scale.toFixed(2));
            gesturechange.rotation = Number(rotation.toFixed(2));
            gesturechange.touches = now;
            e.target.dispatchEvent(gesturechange);
          }
        }, !1);

        document.addEventListener("touchend", e => {
          if (istouch) {
            istouch = !1;
            canMove = !0;
            e.target.dispatchEvent(gestureend);
          }
        }, !1);
      }
      addGesture();

      //删除原始元素
      const deletDefault = () => {
        let imgRealArr = that.getEle(that.element).querySelectorAll("img"),
          imgArr = Array.prototype.slice.call(imgRealArr);
        imgArr.forEach((cur, idx) => {
          let current = imgRealArr[idx];
          JSON.parse(current.getAttribute("Pd-move")) && current.parentElement.removeChild(current);
        });
      }

      //设置参数
      const setConfig = (ele, eleconfig) => {
        for (let a of ele.querySelectorAll(".Pd-ImgTransit-btn")) a.style.transform = `scale(${1 / (eleconfig.scale / 100)}) rotate(${-1*eleconfig.rotate}deg)`;
        return ele.style.transform = `translate3d(${eleconfig.translate}) scale(${eleconfig.scale / 100}) rotate(${eleconfig.rotate}deg)`;
      }

      //获取中心
      const getCenterPoint = ele => {
        return {
          x: ele.getBoundingClientRect().left + ele.offsetWidth / 2,
          y: ele.getBoundingClientRect().top + ele.offsetHeight / 2,

        };
      }

      //添加容器事件
      const addEvent = ele => {
        let eleReal = this.getEle(this.element).querySelectorAll(`.Pd-ImgTransit`),
          eleArr = Array.prototype.slice.call(eleReal),
          eleConfig = [];

        eleArr.forEach((cur, idx) => {
          let w = ele[idx].width,
            h = ele[idx].height;
          eleConfig.push({
            translate: `0,0,0`,
            scale: 100,
            rotate: 0
          });
          eleReal[idx].style.width = `${w}px`;
          eleReal[idx].style.height = `${h}px`;
          setConfig(eleReal[idx], eleConfig[idx]);
          eleReal[idx].style.position = "absolute";
          eleReal[idx].style.top = "50%";
          eleReal[idx].style.left = "50%";
          eleReal[idx].style.margin = `-${(h/2) + (config.padding)}px 0 0 -${(w/2) + (config.padding)}px`;
          eleReal[idx].style.zIndex = idx + 1;
          eleReal[idx].style.padding = `${config.padding}px`;

          let touchStart, touchEnd, touchMove, touchResize, touchRotate, touchDelete, centerPoint, prevAngle, touchX = 0,
            touchY = 0,
            startX, startY, prevScale;

          touchStart = event => {
            event.preventDefault();
            if (JSON.parse(event.target.getAttribute("pd-move")) || JSON.parse(event.target.parentElement.getAttribute("pd-move"))) eleReal[idx].querySelector("img").style.transform = "scale(1.04)";
            config.callback && config.callback({
              type: "choose",
              obj: eleReal[idx]
            });
          }
          touchEnd = event => {
            event.preventDefault();
            eleReal[idx].querySelector("img").style.transform = "scale(1)";
          }
          //移动事件
          touchMove = event => {
            if (event.touches.length < 2) {
              event.stopImmediatePropagation();
              event.preventDefault();

              const changePosition = () => {
                let nowx = event.changedTouches[0].pageX,
                  nowy = event.changedTouches[0].pageY,
                  w = event.target.getBoundingClientRect().width,
                  h = event.target.getBoundingClientRect().height,
                  icon = event.target.parentElement.querySelectorAll(".Pd-ImgTransit-btn")[0].getBoundingClientRect(),
                  iconw = icon.width / 2;
                touchX = nowx - startX;
                touchY = nowy - startY;
                let getBounding = eleReal[idx].parentElement.getBoundingClientRect(),
                  parentBox = {
                    width: config.bounds ? getBounding.width + config.outBounds : getBounding.width,
                    height: config.bounds ? getBounding.height + config.outBounds : getBounding.height
                  };

                if (config.bounds) {
                  if (Math.abs(touchX) >= (parentBox.width / 2) - (w / 2) - iconw) {
                    if (touchX < 0) {
                      touchX = -1 * ((parentBox.width / 2) - (w / 2) - iconw);
                    } else {
                      touchX = (parentBox.width / 2) - (w / 2) - iconw;
                    }
                  }
                  if (Math.abs(touchY) >= (parentBox.height / 2) - (h / 2) - iconw) {
                    if (touchY < 0) {
                      touchY = -1 * ((parentBox.height / 2) - (h / 2) - iconw);
                    } else {
                      touchY = (parentBox.height / 2) - (h / 2) - iconw;
                    }
                  }

                }
                eleConfig[idx].translate = `${touchX}px,${touchY}px,0`;
                setConfig(eleReal[idx], eleConfig[idx]);
              }
              config.callback && config.callback({
                type: "move",
                obj: eleReal[idx]
              });
              canMove && changePosition();
            }
          }
          //缩放事件
          touchResize = event => {
            event.stopImmediatePropagation();

            event.preventDefault();
            if (canMove) {
              let x = event.changedTouches[0].pageX - eleReal[idx].getBoundingClientRect().left;
              if (x > 0 && eleConfig[idx].scale > config.scale.min) {
                eleConfig[idx].scale -= config.scale.rate;
              }
              if (x < 0 && eleConfig[idx].scale < config.scale.max) {
                eleConfig[idx].scale += config.scale.rate;
              }
            }

            if (event.touches.length >= 2) {
              if (config.scale.enable) {
                if (event.scale > prevScale) {
                  if (eleConfig[idx].scale < config.scale.max) eleConfig[idx].scale += event.scale;
                } else {
                  if (eleConfig[idx].scale > config.scale.min) eleConfig[idx].scale -= event.scale * 10;
                }
              }

              if (config.rotate.enable) {
                if (event.rotation > 0) {
                  eleConfig[idx].rotate += Math.abs(event.rotation) / 30;
                } else {
                  eleConfig[idx].rotate -= Math.abs(event.rotation) / 30;
                }
              }

            }
            setConfig(eleReal[idx], eleConfig[idx]);
            config.callback && config.callback({
              type: "resize",
              obj: eleReal[idx]
            });
          }
          //旋转事件
          touchRotate = event => {
            event.stopImmediatePropagation();
            event.preventDefault();
            const changeRotate = () => {
              let angle = Math.atan2(event.changedTouches[0].pageY - centerPoint.y, event.changedTouches[0].pageX - centerPoint.x);
              eleConfig[idx].rotate = Math.floor((angle - prevAngle) * 180 / Math.PI) * config.rotate.rate;
              setConfig(eleReal[idx], eleConfig[idx]);
            }
            config.callback && config.callback({
              type: "rotate",
              obj: eleReal[idx]
            });
            canMove && changeRotate();
          }
          //删除事件
          touchDelete = event => {
            event.stopImmediatePropagation();
            event.preventDefault();
            const deleteObj = () => {
              eleConfig[idx].translate = "0,0,0";
              eleConfig[idx].rotate = 0;
              eleConfig[idx].scale = 100;
              setConfig(eleReal[idx], eleConfig[idx]);
              eleReal[idx].style.display = "none";
              config.callback && config.callback({
                type: "delete",
                obj: eleReal[idx]
              });
            }
            canMove && deleteObj();
          }

          //绑定所有操作						
          eleReal[idx].addEventListener("touchstart", touchStart);
          eleReal[idx].addEventListener("touchend", touchEnd);
          if (config.move) {
            eleReal[idx].addEventListener("touchstart", event => {
              if (event.touches.length < 2) {
                startX = event.changedTouches[0].pageX - touchX;
                startY = event.changedTouches[0].pageY - touchY;
                eleReal[idx].addEventListener("touchmove", touchMove);
              }
            });
          }
          if (config.icon && config.scale.enable) eleReal[idx].querySelectorAll(`.Pd-resize`)[0].addEventListener("touchmove", touchResize);
          if (config.icon && config.rotate.enable) {
            eleReal[idx].querySelectorAll(`.Pd-rotate`)[0].addEventListener("touchstart", event => {
              centerPoint = getCenterPoint(eleReal[idx]);
              prevAngle = Math.atan2(event.changedTouches[0].pageY - centerPoint.y, event.changedTouches[0].pageX - centerPoint.x) - eleConfig[idx].rotate * Math.PI / 180;
            });
            eleReal[idx].querySelectorAll(`.Pd-rotate`)[0].addEventListener("touchmove", touchRotate);
          }
          if (!config.icon) {
            eleReal[idx].querySelector("img").addEventListener("gesturestart", event => {
              prevScale = event.scale;
              if (config.move) {
                eleReal[idx].removeEventListener("touchmove", touchMove);

                eleReal[idx].querySelector("img").addEventListener("gestureend", () => {
                  eleReal[idx].addEventListener("touchmove", touchMove);
                });
              }
              eleReal[idx].querySelector("img").addEventListener("gesturechange", touchResize);
            });
          }
          if (config.icon && config.delete) eleReal[idx].querySelectorAll(`.Pd-delete`)[0].addEventListener("touchstart", touchDelete);

          //隐藏操作按钮
          const hideBtn = () => {
            canMove = !1;
            let allCon = document.querySelectorAll(`.Pd-ImgTransit`),
              allBtn = document.querySelectorAll(`.Pd-ImgTransit-btn`);
            for (let a of allCon) a.style.border = "none";
            for (let a of allBtn) a.style.opacity = 0;
          }
          config.icon && hideBtn();
          //显示操作按钮
          const showBtn = tag => {
            canMove = !0;
            let curBtn = tag.querySelectorAll(`.Pd-ImgTransit-btn`);
            for (let a of curBtn) {
              a.style.opacity = 1;
              if (config.border) tag.style.border = "2px dashed white";
              topIndex++;
              tag.style.zIndex = topIndex;
            }
          }

          //显示当前按钮
          document.addEventListener("touchstart", event => {
            if (config.icon) {
              hideBtn();
              event.stopImmediatePropagation();
              JSON.parse(event.target.getAttribute("pd-move")) && showBtn(event.target);
              if (event.target.parentElement) JSON.parse(event.target.parentElement.getAttribute("pd-move")) && showBtn(event.target.parentElement);
            } else {
              if (event.target.parentElement) {
                if (JSON.parse(event.target.parentElement.getAttribute("pd-move"))) {
                  canMove = !0;
                } else {
                  canMove = !1;
                }
              }
            }
          });
        });
      }

      new Promise(next => {
        let eleArr = [];
        imgArr.forEach((current, idx) => {
          let cur = imgRealArr[imgIndex[idx]],
            btn = "";
          if (config.icon) {
            if (config.scale.enable) btn += icon.resize;
            if (config.rotate.enable) btn += icon.rotate;
            if (config.delete) btn += icon.delete;
          }

          that.append(`<div class="Pd-ImgTransit" Pd-index="${imgIndex[idx]}">${btn}</div>`);
          let imgCon = that.get.querySelectorAll(`.Pd-ImgTransit`)[idx];
          cur.style.transition = "transform .4s ease-in";
          [].slice.call(cur.attributes).forEach(atts => {

            if (atts.name !== "style" && atts.name !== "id" && atts.name !== "class") imgCon.setAttribute(atts.name, atts.value);
          });
          imgCon.appendChild(cur);
          cur.removeAttribute("Pd-move");
          eleArr.push(cur);
          next(eleArr);
        });
      }).then((ele) => {
        deletDefault();
        addEvent(ele);
      });
    }
    //微信SDK
    wxSDK(options) {
      let config = {
        //相关接口地址(类型：字符串)
        apiUrl: "http://wx.pandorajs.com/wxshare.ashx?url=",
        //分享标题(类型：字符串或数组)
        title: ["Share to Timeline", "Share to Friends"],
        //分享描述(类型：字符串)
        desc: "Simple for this",
        //分享图(类型：字符串或数组)
        sharepics: "http://pandorajs.com/share_ico.jpg",
        //分享链接(类型：字符串或数组)
        sharelinks: location.href,
        //调试(类型：布尔)
        debug: !1,
        //微信jsApiList(类型：数组)
        jsApiList: null,
        //回调方法
        callback: {
          //分享就绪(类型：方法)
          ready: null,
          //分享成功(类型：方法)
          success: null,
          //分享失败或取消(类型：方法)
          error: null
        }
      };
      config = this.extend(config, options);
      let sdk = "//pandorajs.com/other/weixin.js";
      if (location.protocol === "file:") sdk = "http://pandorajs.com/other/weixin.js";
      const scriptTag = document.createElement("script");
      scriptTag.id = "Pd_share";
      scriptTag.src = sdk;
      if (this.getEle("#Pd_share")) {
        new PandoraAPI("#Pd_share").remove();
        document.body.appendChild(scriptTag);
      } else {
        document.body.appendChild(scriptTag);
      }
      let jsApiList = ["onMenuShareTimeline", "onMenuShareAppMessage", "updateTimelineShareData", "updateAppMessageShareData"];
      if (config.jsApiList) {
        config.jsApiList.map(e => {
          jsApiList.push(e);
        });
      }

      const isObj = con => {
        if (typeof con === "object") {
          return !0;
        } else {
          return !1;
        }
      }

      const success = res => {
        wx.config({
          debug: config.debug,
          appId: res.appId,
          timestamp: res.timestamp,
          nonceStr: res.nonceStr,
          signature: res.signature,
          jsApiList: jsApiList
        });
        wx.ready(() => {
          new Promise(next => {
            if (wx.onMenuShareTimeline) {
              wx.onMenuShareTimeline({
                title: isObj(config.title) ? config.title[0] : config.title,
                link: isObj(config.sharelinks) ? config.sharelinks[0] : config.sharelinks,
                imgUrl: isObj(config.sharepics) ? config.sharepics[0] : config.sharepics,
                success: config.callback.success,
                cancel: config.callback.error
              });
            } else {
              wx.updateTimelineShareData({
                title: isObj(config.title) ? config.title[0] : config.title,
                link: isObj(config.sharelinks) ? config.sharelinks[0] : config.sharelinks,
                imgUrl: isObj(config.sharepics) ? config.sharepics[0] : config.sharepics,
                success: config.callback.success,
                cancel: config.callback.error
              });
            }

            if (wx.onMenuShareAppMessage) {
              wx.onMenuShareAppMessage({
                title: isObj(config.title) ? config.title[1] : config.title,
                desc: config.desc,
                link: isObj(config.sharelinks) ? config.sharelinks[1] : config.sharelinks,
                imgUrl: isObj(config.sharepics) ? config.sharepics[1] : config.sharepics,
                success: config.callback.success,
                cancel: config.callback.error
              });
            } else {
              wx.updateAppMessageShareData({
                title: isObj(config.title) ? config.title[1] : config.title,
                desc: config.desc,
                link: isObj(config.sharelinks) ? config.sharelinks[1] : config.sharelinks,
                imgUrl: isObj(config.sharepics) ? config.sharepics[1] : config.sharepics,
                success: config.callback.success,
                cancel: config.callback.error
              });
            }
            next();
          }).then(() => {
            config.callback.ready && config.callback.ready();
          });
        });
      }

      scriptTag.onload = () => {
        this.ajax({
          url: `${config.apiUrl}${encodeURIComponent(location.href)}`,
          async: !0,
          type: "post",
          success: success
        });
      }
      return this;
    }
  }
}
const Pandora = class extends PandoraJs(PandoraAPI) {
  constructor(element) {
    super(element);
  }
}
try {
  jQuery
} catch (err) {
  window.$ = element => {
    return new Pandora(element);
  }
  console.warn("new Pandora() 可以简写为 $()");
}
window.PD = element => {
  return new Pandora(element);
}
